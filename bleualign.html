<!DOCTYPE html>
<html>
	<head>
		<title>Bleualign input explorer</title>
		<style>
			html {
				margin: 0;
				padding: 0;
				height: 100%;
			}

			body {
				font: 14px/18px sans-serif;
				--highlight: rgba(255,204,0,0.4);
				box-sizing: border-box;
				height: 100%;
				margin: 0;
				padding: 0;
				display: flex;
				flex-direction: column;
				justify-content: stretch;
			}

			select {
				font: inherit;
			}

			#controls {
				flex:  0 0 auto;
				display: flex;
				background: white;
				padding: 0.25em 1em;
				border-top: 1px solid #ccc;
				justify-content: flex-end;
			}

			#navigator, #document {
				display: flex;
			}

			#navigator {
				flex: 0 0 auto;
				height: 20vh;
				overflow: hidden;
				resize: vertical;
				padding: 0.5em;
				border-bottom: 1px solid #ccc;
			}

			#navigator > select {
				flex: 1 1 0;
				height: 100%;
				border: 1px solid #ccc;
			}

			#document {
				flex: 1 1 auto;
				overflow: hidden;
			}

			#document .col {
				flex: 1 1 0;
				padding: 1em;
				overflow-y: auto;
			}

			#document .separator {
				flex:  0 0 1px;
				background: #ccc;
			}

			*[data-label]::before {
				content: attr(data-label);
				color: #ccc;
				display: block;
				text-align: center;
			}

			.sentence {
				display: block;
				margin: .25em 0;
				padding: .25em;
				background-color: rgba(var(--alignment-color), var(--alignment-opacity));
			}

			.sentence::before {
				content: attr(data-index);
				color: #ccc;
				padding-right: 1ch;
			}


		</style>
	</head>
	<body>
		<div id="navigator">
			<select id="file-list" size=10 resize></select>
			<select id="document-list" size=10></select>
		</div>
		<div id="document">
			<div class="col" data-property="text_src" data-label="Foreign text"></div>
			<div class="col" data-property="align_src" data-label="Foreign text translated to English"></div>
			<div class="col" data-property="text_trg" data-label="English text"></div>
			<div class="separator"></div>
			<div class="col" data-property="aligned_src" data-label="Aligned Foreign text"></div>
			<div class="col" data-property="aligned_trg" data-label="Aligned English text"></div>
		</div>
		<div id="controls">
			<input type="range" min=0 max=100 id="alignment-opacity" value=40 title="Alignment colour opacity">
		</div>
		<script>
			const colours = [
						'230, 25, 75',
						' 60,180, 75',
						'255,225, 25',
						'  0,130,200',
						'245,130, 48',
						'145, 30,180',
						' 70,240,240',
						'240, 50,230',
						'210,245, 60',
						'250,190,190',
						'  0,128,128',
						'230,190,255',
						'170,110, 40',
						'255,250,200',
						'128,  0,  0',
						'170,255,195',
						'128,128,  0',
						'255,215,180',
						'  0,  0,128',
						'128,128,128',
						'255,255,255',
						'  0,  0,  0',
					];

			function connect(selector, callback) {
				const el = document.querySelector('#alignment-opacity');
				const key = `${selector}::value`;

				// Restore stored value
				if (key in window.localStorage)
					el.value = JSON.parse(window.localStorage[key]);

				// Listen for updates
				el.addEventListener('input', e => {
					window.localStorage[key] = JSON.stringify(el.value);
					callback(el.value);
				});

				// Call once to initialize
				callback(el.value);
			}

			Array.prototype.last = function() {
				return this.length > 0 ? this[this.length - 1] : undefined;
			}

			let cssRule = -1;

			function highlight(index) {
				const sheet = document.querySelector('style').sheet;
				if (cssRule != -1) {
					sheet.removeRule(cssRule);
					cssRule = -1;
				}

				if (index !== undefined)
					cssRule = sheet.insertRule(`.sentence[data-index='${index}'] {
						outline: 2px solid black;
					}`);
			}

			async function populate(selector, url, callback) {
				const select = document.querySelector(selector);
				select.disabled = true;
				while (select.options.length > 0)
					select.options.remove(0);
				const response = await fetch(url);
				const items = await response.json();
				items.forEach(item => select.options.add(callback(item)));
				select.disabled = false;
			}

			async function fetchFileList() {
				populate('#file-list', '/files/', file => {
					const option = new Option(file.name)
					option.dataset.link = file.link;
					return option;
				});
			}

			async function fetchDocumentList(link) {
				populate('#document-list', link, document => {
					const option = new Option(document.name)
					option.dataset.link = document.link;
					return option;
				});
			} 

			async function fetchDocument(link) {
				const container = document.querySelector('#document');
				
				// Clear (to show something is happening)
				Array.from(container.querySelectorAll('[data-property]')).forEach(component => {
					while (component.firstChild)
						component.removeChild(component.firstChild);
				});

				// Download
				const response = await fetch(link);
				const doc = await response.json();
				
				// Populate
				Array.from(container.querySelectorAll('[data-property]')).forEach(component => {
					doc[component.dataset.property].forEach((line, n) => {
						const span = document.createElement('span');
						span.classList.add('sentence');
						span.textContent = line;
						span.dataset.index = n;
						component.appendChild(span);
					})
				});

				// Mark matches
				// [
				// 	prop of aligned, cols of aligned data,
				// 	prop of text it matched against, cols of these texts
				// ]
				[
					[
						'aligned_src', ['aligned_src'],
						'text_src', ['text_src', 'align_src']
					],
					[
						'aligned_trg', ['aligned_trg'],
						'text_trg', ['text_trg']
					]
				].forEach(([aligned_prop, aligned_cols, text_prop, text_cols]) => {
					const alignments = doc[aligned_prop].reduce((alignment, sentence, i) => {
						let search = doc[text_prop];

						for (offset = alignment.length > 0 ? alignment.last().src.last() : 0; offset < search.length; ++offset) {
							if (offset == 0 && i == 0)
								console.log([search[offset], sentence]);

							// If this sentence is longer than the one we're looking for, it is definitely a miss.
							if (search[offset].length > sentence.length)
								continue;

							// If this sentence starts differently, it's a miss
							if (search[offset] != sentence.substr(0, search[offset].length))
								continue;

							// Now let's see how many sentences we need to glue to get the sentence we're looking for
							for (len = 1; len <= search.length - offset; ++len) {
								const text = search.slice(offset, offset + len).join(' ');
								
								// If we matched it, good! We're done searching for this sentence
								if (text == sentence)
									return alignment.concat([{src: [offset, offset + len], trg: [i, i + 1]}]);

								// If we joined a text longer than sentence, stop trying to glue
								// and try the next beginning sentence.
								if (text.length > sentence)
									break;
							}
						}

						// In case we didn't find anything for this sentence
						return alignment;
					}, []);

					console.log(alignments);

					// Colour them ranges
					alignments.forEach((range, i) => {
						aligned_cols.forEach(col => {
							Array.from(container.querySelectorAll(`[data-property="${col}"] > .sentence`)).slice(...range.trg).forEach(span => {
								span.style.setProperty('--alignment-color', colours[i % 20]);
							});
						});

						text_cols.forEach(col => {
							Array.from(container.querySelectorAll(`[data-property="${col}"] > .sentence`)).slice(...range.src).forEach(span => {
								span.style.setProperty('--alignment-color', colours[i % 20]);
							});
						});
					});
				});
			}

			const columns = document.querySelectorAll('.col');
			let currentCol = null;

			columns.forEach(col => {
				col.addEventListener('mouseenter', e => {
					currentCol = col;
				})
			});

			columns.forEach(col => {
				col.addEventListener('scroll', e => {
					if (col === currentCol) {
						const frac = col.scrollTop / (col.scrollHeight - col.offsetHeight);
						columns.forEach(col => {
							if (col !== currentCol)
								col.scrollTop = frac * (col.scrollHeight - col.offsetHeight);
						});
					}
				}, {passive: true})
			});

			document.querySelector('#file-list').addEventListener('input', e => {
				fetchDocumentList(e.target.options[e.target.selectedIndex].dataset.link);
			});

			document.querySelector('#document-list').addEventListener('input', e => {
				highlight();
				fetchDocument(e.target.options[e.target.selectedIndex].dataset.link);
			});

			document.querySelector('#document').addEventListener('click', e => {
				if (e.target.matches('.sentence'))
					highlight(e.target.dataset.index);
			});

			connect('#alignment-opacity', value => {
				document.body.style.setProperty('--alignment-opacity', parseInt(value) / 100);
			});

			fetchFileList();
		</script>
	</body>
</html>
