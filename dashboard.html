<!DOCTYPE html>
<html>
	<head>
		<title>Paracrawl dashboard</title>
		<style>
			body {
				font:  14px/18px sans-serif;
			}

			#job-grid	{
				width: 100%;
				table-layout: fixed;
			}

			#job-grid .job {
				display: block;
				text-decoration: none;
				padding: 0 0.25em;
				margin: 0.125em 0;
			}

			#job-grid .job:hover {
				text-decoration: underline;
			}

			#job-grid .job.completed,
			#job-grid .progress-bar .completed {
				background: #0a0;
				color: white;
			}

			#job-grid .job.pending,
			#job-grid .progress-bar .pending {
				background: #3cf;
				color: white;
			}

			#job-grid .job.running,
			#job-grid .progress-bar .running {
				background: #fc0;
			}

			#job-grid .job.cancelled,
			#job-grid .progress-bar .cancelled {
				background: #333;
				color: white;
			}

			#job-grid .job.timeout,
			#job-grid .progress-bar .timeout {
				background: #c33;
				color: white;
			}

			#job-grid th, #job-grid td {
				vertical-align: top;
			}

			#job-grid tr:nth-child(even) {
				background: #eee;
			}

			#job-grid .unavailable::after {
				content: 'n/a';
				color: #ccc;
				text-align: center;
			}

			#job-grid thead td:first-child {
				width: 2em;
			}

			.job-array h3 {
				font-size: inherit;
				font-weight: normal;
				margin: 0;
			}

			.job-array ol {
				margin: 0;
				padding: 0 .4em 0 0;
			}

			.job-array.collapsed ol {
				display: none;
			}

			.job-array .progress {
				float: right;
				font-size: 0.8em;
				line-height: 1.7;
				padding-right: 0.5em;
				pointer-events: none;
			}

			.job-array .progress-bar {
				display: block;
				width: 100%;
				font: 4px/4px sans-serif;
				background: white;
			}

			.job-array .progress-bar > div {
				display: inline-block;
				height: 1em;
			}

			/*
			.job-array:not(.running) .progress-bar {
				display: none;
			}
			*/

			.collapsible-handle {
				cursor: pointer;
			}

			.collapsible-handle::before {
				content: '';
				display: inline-block;
				width: 0;
				border: .4em solid black;
				border-top-color: transparent;
				border-right-color: transparent;
				border-bottom-color: transparent;
				transform-origin: 0 50%;
			}

			.collapsible:not(.collapsed) .collapsible-handle::before {
				transform: rotate(90deg) translateY(-25%);
			}

		</style>
	</head>
	<body>
		<script>
			function identity(x) {
				return x;
			}

			class List extends EventTarget {
				constructor(keyFn) {
					super();
					this._keyFn = keyFn || identity;
					this._index = new Map();
				}

				add(item) {
					const key = this._keyFn(item);
					
					if (this._index.has(key)) {
						const current = this._index.get(key);
						Object.assign(current, item);
						current.dispatchEvent(new CustomEvent('update', {detail: current}));
					} else {
						const current = new EventTarget();
						this._index.set(key, current);
						Object.assign(current, item);
						this.dispatchEvent(new CustomEvent('add', {detail: current}));
					}
				}

				delete(item) {
					this._index.delete(this._keyFn(item));
					current.dispatchEvent(new CustomEvent('delete', {detail: item}))
				}

				update(items) {
					items.forEach(item => this.add(item));
				} 

				sync(items) {
					const visited = new Set();

					items.forEach(item => {
						visited.add(this._keyFn(item));
						this.add(item);
					});

					this._index.forEach((item, key) => {
						if (!visited.has(this._keyFn(key)))
							this.delete(item);
					});
				}

				find(key) {
					return this._index.get(key);
				}

				forEach(fn) {
					this._index.forEach(fn);
				}

				get length() {
					return this._index.size;
				}
			}

			class Interval extends EventTarget {
				constructor(fn, interval) {
					super();
					this.fn = fn;
					this.interval = interval;
					this.timeout = null;
				}

				start() {
					clearTimeout(this.timeout);
					this.dispatchEvent(new CustomEvent('start'));
					this.timeout = setTimeout(this.trigger.bind(this), this.interval);
				}

				startImmediate() {
					clearTimeout(this.timeout);
					this.dispatchEvent(new CustomEvent('start'));
					this.timeout = setTimeout(this.trigger.bind(this), 0);
				}

				stop() {
					this.dispatchEvent(new CustomEvent('stop'));
					clearTimeout(this.timeout);
					this.timeout = null;
				}

				async trigger() {
					try {
						await this.fn();
					} catch (e) {
						this.dispatchEvent(new CustomEvent('error', {detail: e}));
					}
					
					// Only schedule again if we didn't get stopped while waiting for fn.
					if (this.timeout !== null)
						this.start();
				}
			}

			class Router {
				constructor() {
					this.routes = [];
					this.states = {};
					this.state = 0;
					this.serial = 0;

					window.addEventListener('popstate', e => {
						if (e.state in this.states)
							this.setState(e.state);
						else
							this.dispatchInternal(document.location.pathname);
					});
				}

				add(pattern, callback) {
					this.routes.push({pattern, callback})
				}

				async dispatchInternal(url) {
					const {route, match} = first(this.routes, route => {
						const match = url.match(route.pattern);
						if (match)
							return {route, match};
					});

					if (!route)
						throw Error(`No route for "${url}"`);

					const state = ++this.serial;
					const page = h('div', {className: 'page'}, []);

					// Fill the page (or hopefully just async start filling it)
					const rv = route.callback(page, {url, match, ...match.groups});

					// Make page visible
					this.states[state] = page;
					this.setState(state);

					// Return possibly the promise of the page callback
					return rv;
				}

				async dispatch(url) {
					const rv = this.dispatchInternal(url);
					window.history.pushState(this.state, '', url);
					return rv;
				}

				setState(state) {
					this.state = state;
					this.render();

					// Clean up old entries
					Object.entries(this.states).forEach(([state, page]) => {
						if (state > this.state) {
							page.dispatchEvent(new CustomEvent('destroy'));
							delete this.states[state];
						}
					});
				}

				render() {
					Object.values(this.states).forEach(page => {
						if (page.parentNode) {
							page.parentNode.removeChild(page)
							page.dispatchEvent(new CustomEvent('hide'));
						}
					});

					if (this.state) {// prevent rendering of 0 state
						const page = this.states[this.state];
						document.body.appendChild(page);
						page.dispatchEvent(new CustomEvent('show'));
					}
				}
			}

			function first(items, fn) {
				/* Similar to Array.prototype.find, but returns return value of fn */
				for (let item of items) {
					let value = fn(item);
					if (value)
						return value;
				}
				return undefined;
			}

			function listen(event, selector, callback) {
				document.body.addEventListener(event, e => {
					if (e.target.matches(selector))
						callback(e);
				});
			}

			function overlay() {
				const root = h('div', {'className': 'overlay'}, [
					h('button', {
						'className': 'close-button',
						'title': 'Close',
						'onclick': e => document.body.removeChild(root)
					}, ['\u00D7'])
				]);
				return document.body.appendChild(root);
			}

			function assign(obj, props) {
				Object.entries(props).forEach(([key, val]) => {
					if (typeof val === 'object' && val !== null && key in obj)
						assign(obj[key], val);
					else
						obj[key] = val;
				});
			}

			function h(name, options, children) {
				const el = document.createElement(name);
				
				if (options)
					assign(el, options);
				
				if (children)
					children.forEach(child => {
						if (!(child instanceof HTMLElement))
							child = document.createTextNode(child);
						el.appendChild(child);
					});

				return el;
			}

			async function fetchJSON(url, options) {
				const response = await fetch(url, options);
				return await response.json();
			}

			/**
			 * Streams text response to textContent of an element. Think tail -f for
			 * http requests.
			 * Returns function that when called stops streaming.
			 */
			function stream(url, el) {
				const abort = new AbortController();

				fetch(url, {signal: abort.signal}).then(async response => {
					const reader = response.body.getReader();

					el.textContent = '';
					const decoder = new TextDecoder("utf-8");

					try {
						while (true) {
							const {done, value} = await reader.read();

							if (done)
								break;

							el.textContent += decoder.decode(value);
						}
					} catch (e) {
						if (e.name !== 'AbortError')
							throw e;
					};
				});

				return () => {
					abort.abort();
				}
			}

			function renderGrid(table, collections) {
				const languages = Array.from(collections.reduce((languages, collection) => {
					collection.languages.forEach(language => languages.add(language))
					return languages
				}, new Set())).sort();

				table.appendChild(h('thead', {}, [
					h('tr', {}, [
						h('td'),
						...collections.map(collection => h('th', {}, [collection.name]))
					])
				]));

				const grid = Object.fromEntries(collections.map(collection => [collection.name, {}]));

				table.appendChild(h('tbody', {},
					languages.map(language => h('tr', {}, [
						h('th', {}, [language]),
						...collections.map(collection => {
							const td = h('td', {}, []);
							if (!collection.languages.includes(language))
								td.classList.add('unavailable');
							grid[collection.name][language] = {td};
							return td;
						})
					]))
				));

				return grid;
			}

			function formatJob(job) {
				if ('ArrayJobId' in job.slurm && 'ArrayTaskId' in job.slurm)
					return `${job.slurm['ArrayJobId']}_${job.slurm['ArrayTaskId']}`;
				else
					return job.slurm['JobId'];
			}

			function formatJobArray(job) {
				const match = job.slurm['JobName'].match(/(\w+)-/)
				return match && match[1] || job.slurm['JobName']
			}

			function formatPercentage(cnt, sum) {
				const frac = sum > 0 ? cnt / sum : 0;
				return Math.floor((frac * 10000.0) / 100.0).toFixed(1) + '%';
			}

			function addJobSection(cell, job) {
				const list = h('ol', {}, []);
				const progress = h('span', {className: 'progress'});
				const bar = h('div', {className: 'progress-bar'}, [
					h('div', {className: 'pending', style: {width: 'var(--pending)'}, title: 'Pending'}),
					h('div', {className: 'running', style: {width: 'var(--running)'}, title: 'Running'}),
					h('div', {className: 'completed', style: {width: 'var(--completed)'}, title: 'Completed'}),
					h('div', {className: 'cancelled', style: {width: 'var(--cancelled)'}, title: 'Cancelled'}),
					h('div', {className: 'timeout', style: {width: 'var(--timeout)'}, title: 'Timeout'}),
				]);

				cell.td.appendChild(h('div', {className: 'job-array collapsible collapsed'}, [
					h('h3', {className: 'collapsible-handle'}, [
						formatJobArray(job),
						progress, bar,
					]),
					list
				]));

				list.update = () => {
					const counts = {
						'job': 0,
						'pending': 0,
						'running': 0,
						'completed': 0,
						'cancelled': 0,
						'timeout': 0,
					};

					list.querySelectorAll('.job').forEach(el => {
						Object.keys(counts).forEach(className => {
							if (el.classList.contains(className))
								counts[className] += 1;
						})
					});

					// Set each state as a percentage variable for css
					Object.keys(counts).forEach(className => {
						list.parentNode.style.setProperty(`--${className}`, formatPercentage(counts[className], counts['job']));
					});
					
					// Mark the whole list as running if there is something running
					list.parentNode.classList.toggle('running', counts['running'] > 0);

					// Update the little progress indicator text
					progress.textContent = `${counts['running']}/${counts['job']}`;
				}

				return list;
			}

			function addJobToGrid(grid, job) {
				const id = job.slurm['ArrayJobId'] || job.slurm['JobId'];

				const cell = grid[job.collection][job.language];

				if (!('lists' in cell))
					cell.lists = {};

				if (!(id in cell.lists))
					cell.lists[id] = addJobSection(cell, job);

				const list = cell.lists[id];
				const link = list.appendChild(h('a',
					{className: 'job', href: job.link},
					[formatJob(job)]));

				const render = () => {
					link.dataset.slurm = JSON.stringify(job.slurm);
					link.title = `Elapsed: ${job.slurm['Elapsed']}`;

					link.classList.toggle('pending',   'State' in job.slurm && job.slurm['State'] == 'PENDING');
					link.classList.toggle('running',   'State' in job.slurm && job.slurm['State'] == 'RUNNING');
					link.classList.toggle('completed', 'State' in job.slurm && job.slurm['State'] == 'COMPLETED');
					link.classList.toggle('timeout',   'State' in job.slurm && job.slurm['State'] == 'TIMEOUT');
					link.classList.toggle('cancelled', 'State' in job.slurm && job.slurm['State'].match(/^CANCELLED/));
					list.update(); // Update list running status
				};

				render();

				job.addEventListener('update', () => render);

				job.addEventListener('delete', () => {
					link.parentNode.removeChild(link)
				}, {once: true});
			}

			const router = new Router();

			const index = new List(job => job.id);

			let lastUpdate = '';
			
			// After that prefer just the queue updates
			const updater = new Interval(async () => {
				return fetchJSON(lastUpdate ? '/jobs/delta/' + lastUpdate : '/jobs/').then(delta => {
					index.update(delta.jobs);
					lastUpdate = delta.timestamp;	
				});
			}, 60 * 1000);

			updater.startImmediate();

			router.add(/^\/$/, async (root) => {
				const collections = await fetchJSON('/collections/');
				collections.sort((left, right) => left.name.localeCompare(right.name));

				const table = h('table', {'id': 'job-grid'});
				root.appendChild(table);

				const grid = renderGrid(table, collections);
				index.forEach(job => addJobToGrid(grid, job))
				
				// When new jobs are found, add them
				const addJob = e => addJobToGrid(grid, e.detail);
				index.addEventListener('add', addJob);

				// Stop listening for new jobs when this page gets scrapped
				root.addEventListener('destroy', e => {
					index.removeEventListener('add', addJob);
				}, {once: true});

				// Refresh now
				// updater.startImmediate();
				
				// // Refresh when page becomes visible again
				// root.addEventListener('show', e => {
				// 	updater.startImmediate();
				// });
			});

			router.add(/^\/jobs\/(?<job_id>\d+)\/(?<job_array_id>\d+)$/, (root, {url, job_id, job_array_id}) => {
				const job = index.find(`${job_id}_${job_array_id}`)

				// Fetch more details about this job
				fetch(url)
					.then(response => response.json())
					.then(job => index.add(job));

				root.appendChild(h('h1', {}, [job.slurm['JobId']]));

				function live(el, render) {
					root.addEventListener('show', e => {
						const stop = render(el);
						root.addEventListener('hide', stop, {once: true});
					});
					return el;
				}

				root.appendChild(h('section', {className: 'stdout'}, [
					h('h2', {}, ['StdOut']),
					live(h('pre'), el => stream(job['stdout'], el))
				]));

				root.appendChild(h('section', {className: 'stderr'}, [
					h('h2', {}, ['StdErr']),
					live(h('pre'), el => stream(job['stderr'], el))
				]));

				function render(el) {
					function update({detail}) {
						const updated = h('dl', {}, Object.entries(detail.slurm).map(([key, value]) => {
							return [
								h('dt', {}, [key]),
								h('dd', {}, [value])
							];
						}).flat(1));
						el.parentNode.replaceChild(updated, el);
						el = updated;
					}

					// Update now (and every time this page becomes visible)
					update({detail:job});

					// Update every time the job changes
					job.addEventListener('update', update);

					// but stop updating once this page is no longer visible.
					return () => root.removeEventListener('update', update);
				}

				root.appendChild(h('section', {className: 'props'}, [
					h('h2', {}, ['Properties']),
					live(h('dl'), render)
				]));
			})

			listen('click', 'a.job', async (e) => {
				try {
					router.dispatch(e.target.pathname);
					e.preventDefault();
				} catch (e) {
					console.error(e);
				}
			});

			function findParent(el, selector) {
				while (el && !el.matches(selector))
					el = el.parentNode;
				return el;
			}

			listen('click', '.collapsible .collapsible-handle', e => {
				findParent(e.target, '.collapsible').classList.toggle('collapsed');
			});

			router.dispatch(document.location.pathname);
		</script>
	</body>
</html>
