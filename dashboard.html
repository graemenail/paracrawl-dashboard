<!DOCTYPE html>
<html>
	<head>
		<title>Paracrawl dashboard</title>
		<style>
			body {
				font:  14px/18px sans-serif;
			}

			#job-grid	{
				width: 100%;
				table-layout: fixed;
			}

			#job-grid .job {
				display: block;
				text-decoration: none;
				padding: 0 0.25em;
				margin: 0.125em 0;
			}

			#job-grid .job:hover {
				text-decoration: underline;
			}

			#job-grid .job.completed,
			#job-grid .progress-bar .completed {
				background: #0a0;
				color: white;
			}

			#job-grid .job.pending,
			#job-grid .progress-bar .pending {
				background: #3cf;
				color: white;
			}

			#job-grid .job.running,
			#job-grid .progress-bar .running {
				background: #fc0;
			}

			#job-grid .job.cancelled,
			#job-grid .progress-bar .cancelled {
				background: #333;
				color: white;
			}

			#job-grid .job.failed,
			#job-grid .progress-bar .failed {
				background: #c33;
				color: white;
			}

			#job-grid .job.hold,
			#job-grid .progress-bar .hold {
				background: #c3c;
				color: white;
			}

			#job-grid thead th {
				position: sticky;
				top: 0;
				background: white;
				z-index: 10;
			}

			#job-grid th, #job-grid td {
				vertical-align: top;
			}

			#job-grid th:empty::after {
				content: 'n/a';
				color: #ccc;
				font-weight: normal;
			}

			#job-grid tr:nth-child(even) {
				background: #eee;
			}

			#job-grid .unavailable::after {
				content: 'n/a';
				color: #ccc;
				text-align: center;
			}

			#job-grid thead td:first-child {
				width: 2em;
			}

			.job-array h3 {
				font-size: inherit;
				font-weight: normal;
				margin: 0;
				position: relative;
				overflow: hidden;
				text-overflow: ellipsis;
				padding: 0 2em 4px 0;
				white-space: nowrap;
			}

			.job-array ol {
				margin: 0;
				padding: 0;
			}

			.job-array.collapsed ol {
				display: none;
			}

			.job-array .progress {
				position: absolute;
				top: 0;
				right: 0;
				font-size: 0.8em;
				line-height: 1.7em;
				pointer-events: none;
			}

			.job-array .progress-bar {
				position: absolute;
				left: 0;
				right: 0;
				bottom: 0;
				height: 4px;
				font: 4px/4px sans-serif;
				background: white;
				white-space: nowrap;
				overflow: hidden;
			}

			.job-array .progress-bar > div {
				display: inline-block;
				height: 1em;
				min-width: 1em;
			}

			.job-array .progress-bar > div[hidden] {
				display: none;
			}

			.job-array.completed .progress-bar {
				opacity: 0.4;
			}

			.collapsible-handle {
				cursor: pointer;
			}

			.collapsible-handle::before {
				content: '';
				display: inline-block;
				width: 0;
				border: .4em solid black;
				border-top-color: transparent;
				border-right-color: transparent;
				border-bottom-color: transparent;
				transform-origin: 0 50%;
			}

			.collapsible:not(.collapsed) .collapsible-handle::before {
				transform: rotate(90deg) translateY(-25%);
			}

			pre .line {
				white-space: pre-wrap;
			}

			pre .marker {
				margin-right: 1em;
  			/*color: #a33;*/
			}

			pre .line[data-collapsed] {
				white-space: nowrap;
				overflow: hidden;
				display: flex;
			}

			pre .line[data-collapsed] .marker {
				flex: 0 0 200px;
				overflow: hidden;
				/* text-overflow: ellipsis; /* does not work with rtl */
				direction: rtl;
  			text-align: left;
			}

			pre .line[data-collapsed] .message {
				flex: 1 1 auto;
				white-space: pre-line;
				height: 1.2em;
				white-space: nowrap;
				text-overflow: ellipsis;
				overflow: hidden;
			}

			.lang-cs td,
			.lang-de td,
			.lang-fi td,
			.lang-ro td,
			.lang-lv td {
				background: rgba(0, 255, 255, 0.1);
			}
		</style>
	</head>
	<body>
		<script>
			const UNSPECIFIED_LANGUAGE = Symbol('UNSPECIFIED_LANGUAGE');
			const UNSPECIFIED_COLLECTION = Symbol('UNSPECIFIED_COLLECTION');

			const COLORS = [
				'#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4',
				'#42d4f4', '#f032e6', '#bfef45', '#fabed4', '#469990', '#dcbeff',
				'#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1',
				'#000075', '#a9a9a9', '#ffffff', '#000000'
			];

			function identity(x) {
				return x;
			}

			class List extends EventTarget {
				constructor(keyFn) {
					super();
					this._keyFn = keyFn || identity;
					this._index = new Map();
				}

				add(item) {
					const key = this._keyFn(item);
					
					if (this._index.has(key)) {
						const current = this._index.get(key);
						assign(current, item);
						current.dispatchEvent(new CustomEvent('update', {detail: current}));
					} else {
						const current = new EventTarget();
						this._index.set(key, current);
						assign(current, item);
						this.dispatchEvent(new CustomEvent('add', {detail: current}));
					}
				}

				delete(item) {
					this._index.delete(this._keyFn(item));
					current.dispatchEvent(new CustomEvent('delete', {detail: item}))
				}

				update(items) {
					items.forEach(item => this.add(item));
				} 

				sync(items) {
					const visited = new Set();

					items.forEach(item => {
						visited.add(this._keyFn(item));
						this.add(item);
					});

					this._index.forEach((item, key) => {
						if (!visited.has(this._keyFn(key)))
							this.delete(item);
					});
				}

				find(key) {
					return this._index.get(key);
				}

				forEach(fn) {
					this._index.forEach(fn);
				}

				get length() {
					return this._index.size;
				}
			}

			class Interval extends EventTarget {
				constructor(fn, interval) {
					super();
					this.fn = fn;
					this.interval = interval;
					this.timeout = null;
				}

				start() {
					clearTimeout(this.timeout);
					this.dispatchEvent(new CustomEvent('start'));
					this.timeout = setTimeout(this.trigger.bind(this), this.interval);
				}

				startImmediate() {
					clearTimeout(this.timeout);
					this.dispatchEvent(new CustomEvent('start'));
					this.timeout = setTimeout(this.trigger.bind(this), 0);
				}

				stop() {
					this.dispatchEvent(new CustomEvent('stop'));
					clearTimeout(this.timeout);
					this.timeout = null;
				}

				async trigger() {
					try {
						await this.fn();
					} catch (e) {
						this.dispatchEvent(new CustomEvent('error', {detail: e}));
					}
					
					// Only schedule again if we didn't get stopped while waiting for fn.
					if (this.timeout !== null)
						this.start();
				}
			}

			class Router {
				constructor() {
					this.routes = [];
					this.states = {};
					this.state = 0;
					this.serial = 0;

					window.addEventListener('popstate', e => {
						if (e.state in this.states)
							this.setState(e.state);
						else
							this.dispatchInternal(document.location.pathname);
					});
				}

				add(pattern, callback) {
					this.routes.push({pattern, callback})
				}

				async dispatchInternal(url) {
					const found = first(this.routes, route => {
						const match = url.match(route.pattern);
						if (match)
							return {route, match};
					});

					if (!found)
						throw Error(`No route for "${url}"`);
					
					const {route, match} = found;
					const state = ++this.serial;
					const page = h('div', {className: 'page'}, []);

					// Fill the page (or hopefully just async start filling it)
					const rv = route.callback(page, {url, match, ...match.groups});

					// Make page visible
					this.states[state] = page;
					this.setState(state);

					// Return possibly the promise of the page callback
					return rv;
				}

				async dispatch(url) {
					const rv = this.dispatchInternal(url);
					window.history.pushState(this.state, '', url);
					return rv;
				}

				setState(state) {
					this.state = state;
					this.render();

					// Clean up old entries
					Object.entries(this.states).forEach(([state, page]) => {
						if (state > this.state) {
							page.dispatchEvent(new CustomEvent('destroy'));
							delete this.states[state];
						}
					});
				}

				render() {
					Object.values(this.states).forEach(page => {
						if (page.parentNode) {
							page.parentNode.removeChild(page)
							page.dispatchEvent(new CustomEvent('hide'));
						}
					});

					if (this.state) {// prevent rendering of 0 state
						const page = this.states[this.state];
						document.body.appendChild(page);
						page.dispatchEvent(new CustomEvent('show'));
					}
				}
			}

			function first(items, fn) {
				/* Similar to Array.prototype.find, but returns return value of fn */
				for (let item of items) {
					let value = fn(item);
					if (value)
						return value;
				}
				return undefined;
			}

			function listen(event, selector, callback) {
				document.body.addEventListener(event, function(e) {
					let el = e.target;
					while(el) {
						if (el.matches(selector))
							return callback(el, e);
						el = el.parentElement;
					};
				});
			}

			function overlay() {
				const root = h('div', {'className': 'overlay'}, [
					h('button', {
						'className': 'close-button',
						'title': 'Close',
						'onclick': e => document.body.removeChild(root)
					}, ['\u00D7'])
				]);
				return document.body.appendChild(root);
			}

			function assign(obj, props) {
				Object.entries(props).forEach(([key, val]) => {
					if (typeof val === 'object' && val !== null && key in obj)
						assign(obj[key], val);
					else
						obj[key] = val;
				});
			}

			function debounce(fn) {
				let promise = null;

				return function debounced() {
					if (!promise) {
						promise = new Promise((accept, reject) => {
							setTimeout(() => {
								try {
									accept(fn.apply(undefined, arguments));
								} catch (e) {
									reject(e);
								} finally {
									promise = null;
								}
							});
						});
					}

					return promise
				}
			}

			function h(name, options, children) {
				const el = document.createElement(name);
				
				if (options)
					assign(el, options);
				
				if (children)
					children.forEach(child => {
						if (!(child instanceof HTMLElement))
							child = document.createTextNode(child);
						el.appendChild(child);
					});

				return el;
			}

			async function fetchJSON(url, options) {
				const response = await fetch(url, options);
				return await response.json();
			}

			/**
			 * fetch() as an async generator, yielding chunks of content as they come in
			 */
			function stream(url) {
				const abort = new AbortController();

				return {
					async *[Symbol.asyncIterator]() {
						const decoder = new TextDecoder("utf-8");

						const response = await fetch(url, {signal: abort.signal});
						const reader = response.body.getReader();
						
						while (true) {
							const {done, value} = await reader.read();

							if (done)
								break;
							
							yield decoder.decode(value);
						}
					},
					abort() {
						abort.abort();
					}
				}
			}

			/**
			 * Generator that wraps another async iterator and yield lines (instead
			 * of chunks as stream() does)
			 */
			async function* lines(generator) {
				const iterator = generator[Symbol.asyncIterator]();
				let buffer = '';

				while (true) {
					const pos = buffer.indexOf('\n');

					// We have a full line in the buffer
					if (pos >= 0) {
						const value = buffer.substr(0, pos);
						buffer = buffer.substr(pos+1);
						yield value;
						continue;
					}

					// We still have data to read?
					const {done, value} = await iterator.next();

					// Yes! Fill buffer and start over
					if (!done) {
						buffer += value; // and we use the value next iteration
						continue;
					}

					// Nope, we're out of data. Yield remaining buffer as a last line.
					if (buffer)
						yield buffer;

					break;
				}
			}

			function streamToElement(url, root) {
				root.innerHTML = ''; // clear

				const markers = {};

				const data = stream(url);
				
				async function render() {
					try {
						for await (let line of lines(data)) {
							const match = line.match(/^(\[.+?\])\t(.+?)$/);
							if (match) {
								if (!(match[1] in markers))
									markers[match[1]] = Object.keys(markers).length;
								const color = COLORS[markers[match[1]] % COLORS.length];
								root.appendChild(h('div', {className: 'line', dataset: {collapsible: true, collapsed: true}}, [
									h('span', {'className': 'marker', style: {color}}, [match[1]]),
									h('span', {'className': 'message'}, [match[2]])
								]));
							} else {
								root.appendChild(h('div', {className: 'line'}, [line]));
							}
						}
					} catch (e) {
						if (e.name !== 'AbortError')
							throw e;
					}
				};

				render(); // Just let it go!

				return data.abort; // Return the stop function
			}

			function renderGrid(table, collections) {
				const SPANISH_COOFFICIAL_LANGUAGES = ['ca', 'eu', 'oc', 'gl'];
				const languages = Array.from(collections.reduce((languages, collection) => {
					collection.languages.forEach(language => languages.add(language))
					return languages
				}, new Set())).sort((a, b) => {
					if (SPANISH_COOFFICIAL_LANGUAGES.includes(a) ^ SPANISH_COOFFICIAL_LANGUAGES.includes(b))
						return SPANISH_COOFFICIAL_LANGUAGES.includes(a) ? -1 : 1;
					else
						return a < b ? -1 : 1;
				});

				// Add the non-language-specific jobs at the end
				languages.push(UNSPECIFIED_LANGUAGE);

				collections = [
					...collections,
					{
						name: UNSPECIFIED_COLLECTION,
						languages: Array.from(languages)
					}
				];

				table.appendChild(h('thead', {}, [
					h('tr', {}, [
						h('td'),
						...collections.map(collection => h('th', {}, [
							collection.name !== UNSPECIFIED_COLLECTION ? collection.name : ''
						]))
					])
				]));

				const grid = Object.fromEntries(collections.map(collection => [collection.name, {}]));

				table.appendChild(h('tbody', {},
					languages.map(language => h('tr', language !== UNSPECIFIED_LANGUAGE ? {className: `lang-${language}`} : {}, [
						h('th', {}, [language !== UNSPECIFIED_LANGUAGE ? language : '']),
						...collections.map(collection => {
							const td = h('td', {}, []);
							if (!collection.languages.includes(language) && language !== UNSPECIFIED_LANGUAGE)
								td.classList.add('unavailable');
							grid[collection.name][language] = {td};
							return td;
						})
					]))
				));

				return grid;
			}

			function formatJob(job) {
				if ('ArrayJobId' in job.slurm && 'ArrayTaskId' in job.slurm)
					return `${job.slurm['ArrayJobId']}_${job.slurm['ArrayTaskId']}`;
				else
					return job.slurm['JobId'];
			}

			function formatJobArray(job) {
				const match = job.slurm['JobName'].match(/(warc2text|reduce-tmx|reduce-tmx-deferred|reduce-classified|reduce-filtered|shard|merge-shard|clean-shard|dedupe|split|translate|tokenise|align|clean)-/)
				return match && match[1] || job.slurm['JobName']
			}

			function formatPercentage(cnt, sum) {
				const frac = sum > 0 ? cnt / sum : 0;
				return Math.floor((frac * 10000.0) / 100.0).toFixed(1) + '%';
			}

			function addJobSection(cell, job) {
				const list = h('ol', {}, []);
				const progress = h('span', {className: 'progress'});
				const bar = h('div', {className: 'progress-bar'}, [
					h('div', { className: 'failed',     title: 'Failed' }),
					h('div', { className: 'completed',  title: 'Completed' }),
					h('div', { className: 'running',    title: 'Running' }),
					h('div', { className: 'pending',    title: 'Pending' }),
					h('div', { className: 'hold',       title: 'Hold' }),
					h('div', { className: 'cancelled',  title: 'Cancelled'}),
				]);

				cell.td.appendChild(h('div', {className: 'job-array collapsible collapsed'}, [
					h('h3', {className: 'collapsible-handle'}, [
						formatJobArray(job),
						progress, bar,
					]),
					list
				]));

				list.update = debounce(() => {
					const counts = {
						'job': 0,
						'pending': 0,
						'hold': 0,
						'running': 0,
						'completed': 0,
						'cancelled': 0,
						'failed': 0,
					};

					list.querySelectorAll('.job').forEach(el => {
						Object.keys(counts).forEach(className => {
							if (el.classList.contains(className))
								counts[className] += 1;
						})
					});

					// Update each bar
					Object.keys(counts).forEach(className => {
						if (className == 'job')
							return; // we don't have a bar for "job"
						const bar = list.parentNode.querySelector(`.progress-bar .${className}`);
						bar.style.width = formatPercentage(counts[className], counts['job']);
						bar.hidden = counts[className] == 0;
					});
					
					// Mark the whole list as running if there is something running
					list.parentNode.classList.toggle('running', counts['running'] > 0);

					// Mark the whole list as completed if all jobs are completed
					list.parentNode.classList.toggle('completed', counts['completed'] == counts['job']);

					// Update the little progress indicator text
					progress.textContent = `${counts['running']}/${counts['job']}`;
				});

				return list;
			}

			function addJobToGrid(grid, job) {
				const id = job.slurm['ArrayJobId'] || job.slurm['JobId'];

				const cell = grid[job.collection || UNSPECIFIED_COLLECTION][job.language || UNSPECIFIED_LANGUAGE];

				if (!cell) {
					console.warn("No cell for ", job.collection, job.language);
					return;
				}

				if (!('lists' in cell))
					cell.lists = {};

				if (!(id in cell.lists))
					cell.lists[id] = addJobSection(cell, job);

				const list = cell.lists[id];
				const link = list.appendChild(h('a',
					{className: 'job', href: job.link},
					[formatJob(job)]));

				const render = () => {
					link.title = `Elapsed: ${job.slurm['Elapsed']}`;

					link.classList.toggle('pending',       'State' in job.slurm && job.slurm['State'] == 'PENDING' && job.slurm['Reason'] != 'JobHeldUser');
					link.classList.toggle('hold',          'State' in job.slurm && job.slurm['State'] == 'PENDING' && job.slurm['Reason'] == 'JobHeldUser');
					link.classList.toggle('running',       'State' in job.slurm && job.slurm['State'] == 'RUNNING');
					link.classList.toggle('completed',     'State' in job.slurm && job.slurm['State'] == 'COMPLETED');
					link.classList.toggle('cancelled',     'State' in job.slurm && job.slurm['State'].match(/^CANCELLED/));
					link.classList.toggle('failed',        'State' in job.slurm && job.slurm['State'].match(/^TIMEOUT|FAILED|OUT_OF_MEMORY$/));
					list.update(); // Update list running status
				};

				render();

				job.addEventListener('update', render);

				job.addEventListener('delete', () => {
					link.parentNode.removeChild(link)
				}, {once: true});
			}

			const router = new Router();

			const index = new List(job => job.id);

			let lastUpdate = '';
			
			// After that prefer just the queue updates
			const updater = new Interval(async () => {
				return fetchJSON(lastUpdate ? '/jobs/delta/' + lastUpdate : '/jobs/').then(delta => {
					index.update(delta.jobs);
					lastUpdate = delta.timestamp;	
				});
			}, 60 * 1000);

			updater.startImmediate();

			router.add(/^\/$/, async (root) => {
				const collections = await fetchJSON('/collections/');
				collections.sort((left, right) => left.name.localeCompare(right.name));

				// const since = h('input', {type: 'datetime-local'});
				// root.appendChild(h('div', {className: 'controls'}, [
				// 	h('label', {}, ['Only show jobs since:', since])
				// ]));

				const table = h('table', {'id': 'job-grid'});
				root.appendChild(table);

				const grid = renderGrid(table, collections);
				index.forEach(job => addJobToGrid(grid, job))
				
				// When new jobs are found, add them
				const addJob = e => addJobToGrid(grid, e.detail);
				index.addEventListener('add', addJob);

				// Stop listening for new jobs when this page gets scrapped
				root.addEventListener('destroy', e => {
					index.removeEventListener('add', addJob);
				}, {once: true});

				// since.addEventListener('input', e => {

				// });

				// Refresh now
				// updater.startImmediate();
				
				// // Refresh when page becomes visible again
				// root.addEventListener('show', e => {
				// 	updater.startImmediate();
				// });
			});

			router.add(/^\/jobs\/(?<job_id>\d+(_\d+)?)\/$/, (root, {url, job_id}) => {
				const job = index.find(job_id)

				// Fetch more details about this job
				fetch(url)
					.then(response => response.json())
					.then(job => index.add(job));

				root.appendChild(h('h1', {}, [job.slurm['JobId']]));

				function live(el, render) {
					root.addEventListener('show', e => {
						const stop = render(el);
						root.addEventListener('hide', stop, {once: true});
					});
					return el;
				}

				root.appendChild(h('section', {className: 'stdout'}, [
					h('h2', {}, ['StdOut']),
					live(h('pre'), el => streamToElement(job['stdout'], el))
				]));

				root.appendChild(h('section', {className: 'stderr'}, [
					h('h2', {}, ['StdErr']),
					live(h('pre'), el => streamToElement(job['stderr'], el))
				]));

				function render(el) {
					function update({detail}) {
						const updated = h('dl', {}, Object.entries(detail.slurm).map(([key, value]) => {
							return [
								h('dt', {}, [key]),
								h('dd', {}, [value])
							];
						}).flat(1));
						el.parentNode.replaceChild(updated, el);
						el = updated;
					}

					// Update now (and every time this page becomes visible)
					update({detail:job});

					// Update every time the job changes
					job.addEventListener('update', update);

					// but stop updating once this page is no longer visible.
					return () => root.removeEventListener('update', update);
				}

				root.appendChild(h('section', {className: 'props'}, [
					h('h2', {}, ['Properties']),
					live(h('dl'), render)
				]));
			})

			listen('click', 'a.job', async (el, e) => {
				try {
					router.dispatch(el.pathname);
					e.preventDefault();
				} catch (err) {
					console.error(err);
				}
			});

			function findParent(el, selector) {
				while (el && !el.matches(selector))
					el = el.parentNode;
				return el;
			}

			// the collapsible lists
			listen('click', '.collapsible .collapsible-handle', el => {
				findParent(el, '.collapsible').classList.toggle('collapsed');
			});

			// the collapsed rows in the log: only collapse/contract when cicking,
			// not when selecting text. (better ui would be a button, but that
			// button would probably be small.)
			listen('mousedown', '[data-collapsible]', (el, e) => {
				let moved = false;

				el.addEventListener('mousemove', e => {
					moved = true;
				}, {once: true});

				el.addEventListener('mouseup', e => {
					if (!moved) {
						if (el.dataset.collapsed)
							delete el.dataset.collapsed;
						else
							el.dataset.collapsed = 'true';
					}
				}, {once: true});
			});

			router.dispatch(document.location.pathname);
		</script>
	</body>
</html>
