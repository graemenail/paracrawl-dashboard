<!DOCTYPE html>
<html>
	<head>
		<title>Paracrawl dashboard</title>
		<style>
			body {
				font:  14px/18px sans-serif;
			}

			#job-grid	{
				width: 100%;
				table-layout: fixed;
			}

			#job-grid .job {
				display: block;
				text-decoration: none;
				padding: 0 0.25em;
				margin: 0.125em 0;
			}

			#job-grid .job:hover {
				text-decoration: underline;
			}

			#job-grid .job.completed,
			#job-grid .progress-bar .completed {
				background: #0a0;
				color: white;
			}

			#job-grid .job.running,
			#job-grid .progress-bar .running {
				background: #fc0;
			}

			#job-grid .job.cancelled,
			#job-grid .progress-bar .cancelled {
				background: #333;
				color: white;
			}

			#job-grid th, #job-grid td {
				vertical-align: top;
			}

			#job-grid tr:nth-child(even) {
				background: #eee;
			}

			#job-grid .unavailable::after {
				content: 'n/a';
				color: #ccc;
				text-align: center;
			}

			#job-grid thead td:first-child {
				width: 2em;
			}

			.job-array h3 {
				font-size: inherit;
				font-weight: normal;
				margin: 0;
			}

			.job-array ol {
				margin: 0;
				padding: 0 .4em 0 0;
			}

			.job-array.collapsed ol {
				display: none;
			}

			.job-array .progress {
				float: right;
				font-size: 0.8em;
				line-height: 1.7;
				padding-right: 0.5em;
				pointer-events: none;
			}

			.job-array .progress-bar {
				display: block;
				width: 100%;
				font: 4px/4px sans-serif;
				background: white;
				pointer-events: none;
			}

			.job-array .progress-bar > div {
				display: inline-block;
				height: 1em;
			}

			.job-array:not(.running) .progress-bar {
				display: none;
			}

			.collapsible-handle {
				cursor: pointer;
			}

			.collapsible-handle::before {
				content: '';
				display: inline-block;
				width: 0;
				border: .4em solid black;
				border-top-color: transparent;
				border-right-color: transparent;
				border-bottom-color: transparent;
				transform-origin: 0 50%;
			}

			.collapsible:not(.collapsed) .collapsible-handle::before {
				transform: rotate(90deg) translateY(-25%);
			}

		</style>
	</head>
	<body>
		<script>
			function identity(x) {
				return x;
			}

			class List extends EventTarget {
				constructor(keyFn) {
					super();
					this._keyFn = keyFn || identity;
					this._index = new Map();
				}

				update(items) {
					const visited = new Set();

					items.forEach(item => {
						const key = this._keyFn(item);
						visited.add(key);

						if (this._index.has(key)) {
							const current = this._index.get(key);
							Object.assign(current, item);
							current.dispatchEvent(new CustomEvent('update', {detail: current}));
						} else {
							const current = new EventTarget();
							this._index.set(key, current);
							Object.assign(current, item);
							this.dispatchEvent(new CustomEvent('add', {detail: current}));
						}
					});

					this._index.forEach((current, key, map) => {
						if (!visited.has(key)) {
							map.delete(key);
							current.dispatchEvent(new CustomEvent('delete', {detail: current}))
						}
					});
				}
			}

			class Interval {
				constructor(fn, interval) {
					this.fn = fn;
					this.interval = interval;
					this.timeout = null;
				}

				start() {
					this.timeout = setTimeout(this.trigger.bind(this), this.interval);
				}

				startImmediate() {
					this.timeout = setTimeout(this.trigger.bind(this), 0);
				}

				stop() {
					clearTimeout(this.timeout);
					this.timeout = null;
				}

				async trigger() {
					await this.fn();
					
					// Only schedule again if we didn't get stopped while waiting for fn.
					if (this.timeout !== null)
						this.start();
				}
			}

			class Router {
				constructor() {
					this.routes = [];
					this.states = {};
					this.state = 0;
					this.serial = 0;

					window.addEventListener('popstate', e => {
						if (e.state in this.states)
							this.setState(e.state);
						else
							this.dispatchInternal(document.location.pathname);
					});
				}

				add(pattern, callback) {
					this.routes.push({pattern, callback})
				}

				async dispatchInternal(url) {
					const {route, match} = first(this.routes, route => {
						const match = url.match(route.pattern);
						if (match)
							return {route, match};
					});

					if (!route)
						throw Error(`No route for "${url}"`);

					const state = ++this.serial;
					const page = h('div', {className: 'page'}, []);

					this.states[state] = page;
					this.setState(state);

					return route.callback(page, {url, match});
				}

				async dispatch(url) {
					const rv = this.dispatchInternal(url);
					window.history.pushState(this.state, '', url);
					return rv;
				}

				setState(state) {
					this.state = state;
					this.render();
				}

				render() {
					Object.values(this.states).forEach(page => {
						if (page.parentNode) {
							page.parentNode.removeChild(page)
							page.dispatchEvent(new CustomEvent('hide'));
						}
					});

					if (this.state) {// prevent rendering of 0 state
						const page = this.states[this.state];
						document.body.appendChild(page);
						page.dispatchEvent(new CustomEvent('show'));
					}
				}
			}

			function first(items, fn) {
				/* Similar to Array.prototype.find, but returns return value of fn */
				for (let item of items) {
					let value = fn(item);
					if (value)
						return value;
				}
				return undefined;
			}

			function listen(event, selector, callback) {
				document.body.addEventListener(event, e => {
					if (e.target.matches(selector))
						callback(e);
				});
			}

			function overlay() {
				const root = h('div', {'className': 'overlay'}, [
					h('button', {
						'className': 'close-button',
						'title': 'Close',
						'onclick': e => document.body.removeChild(root)
					}, ['\u00D7'])
				]);
				return document.body.appendChild(root);
			}

			function assign(obj, props) {
				Object.entries(props).forEach(([key, val]) => {
					if (typeof val === 'object' && key in obj)
						assign(obj[key], val);
					else
						obj[key] = val;
				});
			}

			function h(name, options, children) {
				const el = document.createElement(name);
				
				if (options)
					assign(el, options);
				
				if (children)
					children.forEach(child => {
						if (!(child instanceof HTMLElement))
							child = document.createTextNode(child);
						el.appendChild(child);
					});

				return el;
			}

			async function fetchJSON(url, options) {
				const response = await fetch(url, options);
				return await response.json();
			}

			function renderGrid(table, collections) {
				const languages = Array.from(collections.reduce((languages, collection) => {
					collection.languages.forEach(language => languages.add(language))
					return languages
				}, new Set())).sort();

				table.appendChild(h('thead', {}, [
					h('tr', {}, [
						h('td'),
						...collections.map(collection => h('th', {}, [collection.name]))
					])
				]));

				const grid = Object.fromEntries(collections.map(collection => [collection.name, {}]));

				table.appendChild(h('tbody', {},
					languages.map(language => h('tr', {}, [
						h('th', {}, [language]),
						...collections.map(collection => {
							const td = h('td', {}, []);
							if (!collection.languages.includes(language))
								td.classList.add('unavailable');
							grid[collection.name][language] = {td};
							return td;
						})
					]))
				));

				return grid;
			}

			function formatJob(job) {
				if ('ArrayJobId' in job.slurm && 'ArrayTaskId' in job.slurm)
					return `${job.slurm['ArrayJobId']}_${job.slurm['ArrayTaskId']}`;
				else
					return job.slurm['JobId'];
			}

			function formatJobArray(job) {
				const match = job.slurm['JobName'].match(/(\w+)-/)
				return match && match[1] || job.slurm['JobName']
			}

			function formatPercentage(cnt, sum) {
				const frac = sum > 0 ? cnt / sum : 0;
				return Math.floor((frac * 10000.0) / 100.0).toFixed(1) + '%';
			}

			function addJobSection(cell, job) {
				const list = h('ol', {}, []);
				const progress = h('span', {className: 'progress'});
				const bar = h('div', {className: 'progress-bar'}, [
					h('div', {className: 'running', style: {width: 'var(--running)'}}),
					h('div', {className: 'completed', style: {width: 'var(--completed)'}}),
					h('div', {className: 'cancelled', style: {width: 'var(--cancelled)'}}),
				]);

				cell.td.appendChild(h('div', {className: 'job-array collapsible collapsed'}, [
					h('h3', {className: 'collapsible-handle'}, [
						formatJobArray(job),
						progress, bar,
					]),
					list
				]));

				list.update = () => {
					const counts = {
						'job': 0,
						'running': 0,
						'completed': 0,
						'cancelled': 0
					};

					list.querySelectorAll('.job').forEach(el => {
						Object.keys(counts).forEach(className => {
							if (el.classList.contains(className))
								counts[className] += 1;
						})
					});

					// Set each state as a percentage variable for css
					Object.keys(counts).forEach(className => {
						list.parentNode.style.setProperty(`--${className}`, formatPercentage(counts[className], counts['job']));
					});
					
					// Mark the whole list as running if there is something running
					list.parentNode.classList.toggle('running', counts['running'] > 0);

					// Update the little progress indicator text
					progress.textContent = `${counts['running']}/${counts['job']}`;
				}

				return list;
			}

			function addJob(grid, job) {
				const id = job.slurm['ArrayJobId'] || job.slurm['JobId'];

				const cell = grid[job.collection][job.language];

				if (!('lists' in cell))
					cell.lists = {};

				if (!(id in cell.lists))
					cell.lists[id] = addJobSection(cell, job);

				const list = cell.lists[id];
				const link = list.appendChild(h('a',
					{className: 'job', href: job.link},
					[formatJob(job)]));

				const render = () => {
					link.dataset.slurm = JSON.stringify(job.slurm);
					link.title = `Elapsed: ${job.slurm['Elapsed']}`;

					link.classList.toggle('running',   'State' in job.slurm && job.slurm['State'] == 'RUNNING');
					link.classList.toggle('completed', 'State' in job.slurm && job.slurm['State'] == 'COMPLETED');
					link.classList.toggle('cancelled', 'State' in job.slurm && job.slurm['State'].match(/^CANCELLED/));
					list.update(); // Update list running status
				};

				render();

				job.addEventListener('update', () => render);

				job.addEventListener('delete', () => {
					link.parentNode.removeChild(link)
				}, {once: true});
			}

			const router = new Router();

			router.add(/^\/$/, async (root) => {
				const collections = await fetchJSON('/collections/');
				collections.sort((left, right) => left.name.localeCompare(right.name));

				const table = h('table', {'id': 'job-grid'});
				root.appendChild(table);

				const grid = renderGrid(table, collections);
				
				const index = new List(job => job.id);
				index.addEventListener('add', e => addJob(grid, e.detail));
				
				const update = async () => {
					const jobs = await fetchJSON('/jobs/');
					index.update(jobs);
				}

				const updater = new Interval(update, 30000);
				root.addEventListener('hide', e => updater.stop());
				root.addEventListener('show', e => updater.startImmediate());
				
				updater.startImmediate(); // We missed the show event for the first load
			});

			router.add(/^\/jobs\/(?<job_id>\d+)\/(?<job_array_id>\d+)$/, async (root, {url}) => {
				const response = await fetch(url);
				const job = await response.json();

				root.appendChild(h('h1', {}, [job.slurm['JobId']]));

				root.appendChild(h('section', {className: 'stdout'}, [
					h('h2', {}, ['StdOut']),
					h('pre', {}, [job['stdout']])
				]));

				root.appendChild(h('section', {className: 'stderr'}, [
					h('h2', {}, ['StdErr']),
					h('pre', {}, [job['stderr']])
				]));

				root.appendChild(h('section', {className: 'props'}, [
					h('h2', {}, ['Properties']),
					h('dl', {}, Object.entries(job.slurm).map(([key, value]) => {
						return [
							h('dt', {}, [key]),
							h('dd', {}, [value])
						];
					}).flat(1))
				]));
			})

			listen('click', 'a.job', async (e) => {
				try {
					router.dispatch(e.target.pathname);
					e.preventDefault();
				} catch (e) {
					console.error(e);
				}
			});

			function findParent(el, selector) {
				while (el && !el.matches(selector))
					el = el.parentNode;
				return el;
			}

			listen('click', '.collapsible .collapsible-handle', e => {
				findParent(e.target, '.collapsible').classList.toggle('collapsed');
			});

			router.dispatch(document.location.pathname);
		</script>
	</body>
</html>
